# 数学约数

#### 任何一个整数都可以分解为质因数,根据`数学质数`文档中的知识,我们可以以下方法求出数的质因数分解

```cpp
int n;cin>>n;
for(int i = 2; i <= n/i; i ++)
    if(n % i == 0)
    {
        int b = 0;
         while(n % i == 0)n /= i,b++;  
        cout << i << ' ' << b << endl;
    }
if(n > 1)cout << n << ' ' << 1;//特判一下,可能最后的n就是最大的那个质因数

```

#### 现在尝试一下求约数

```cpp
vector<int> find(int n)
{
    vector<int>res;
    for(int i = 1; i <= n / i; i ++)
    {
        if( n % i == 0)
        {
            res.push_back(i);
            if(n/i != i)res.push_back(n/i);
        }
    }
    return res;
}

int main()
{
    int t;cin>>t;
    while(t --)
    {
        int n;cin>>n;
        vector<int>res = find(n);
        sort(res.begin(), res.end());
        for(auto s : res)
        cout << s << ' ';
        cout <<endl; 
    }
}
```

#### 从上面代码中,只要一个数是n的约数,就可以push另一个约数到数值中

#### 给定n个数,求这些数乘积的约数,例如输入 `4 5 2`,就是要求4\*5\*2的约数

#### 首先每个约数都可以被分解为原数的质因数乘积

#### 例如,求12有多少个约数?我们可以这么求: 12 可以分解为：2^2*3^1。所以2可以取 0 ~ 2个，3种取法。3可以取 0~1 个，2种取法。12的约数一共：2 * 3 = 6个. 了解这种方法求一个数的约数,我们可以得到一个公式: N = (p1^x1)(p^x2)(p3^x3)…(pk^xk)，其中pi为质数。则N的约数个数为：(x1+1)(x2+1)(x3+1)…(xk+1)

#### 但是题目要求的是n个数的乘积求约数,如何解决? 事实上,其实就是对每个数分别进行这样的操作

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;
const int N = 1e9+7;//mod N 是题目要求
int main()
{
    int n;cin>>n;
    unordered_map<int,int>primes;
    while(n --)
    {
        int x;cin>>x;
        for(int i = 2; i <= x/i; i ++)
            while(x%i == 0)
            {
                x /= i;
                primes[i]++;
            }
        if(x > 1)primes[x]++;
    }
    long long res = 1;
    for(auto p : primes)
        res = res*(p.second+1) % N;
    cout << res;
}
```

#### 我们分解完每个数,再相乘,不就相当于对原数分解吗?这里相乘就变成相应指数相加`primes[i]++`,最后套公式解决了这道题

#### 如果题目要求我们求约数之和呢?约数的个数不包含约数具体的信息啊,好像没办法从上面获得解决手段

### 这里先给出以上和此题所有公式: 

$$
N = p1^{c1} * p2^{c2} * … *pk^{ck} 
\\
约数个数 =  (c1 + 1) * (c2 + 1) * … * (ck + 1)
\\
约数之和 = (p1^0 + p1^1 + … + p1^{c1}) * … * (pk^0 + pk^1 + … + pk^{ck})
\\
$$



#### 把式子展开,我们就可以发现,实际上就是不同质因数的排列组合再相加,这不正好就是约数之和吗

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e9+7;//题目要求
int main()
{
    int n;cin>>n;
    unordered_map<int,int>primes;
    while(n --)
    {
        int x;cin>>x;
        for(int i = 2; i <= x/i; i ++)
            while(x % i == 0)
            {
                x /= i;
                primes[i]++;
            }
        if(x > 1)primes[x]++;
    }
    long long res = 1;
    for(auto p : primes)
    {
        int a = p.first, b = p.second;
        long long t = 1;
        while(b --)t = (t*a + 1) % N;
        res = res * t % N;
    }
    cout << res;
}
```

#### 新定义: ϕ(N)欧拉函数,意思是1-N中与N互质的数的个数

#### **互质**:若N个整数的最大公约数是1，则称这N个整数互质。

#### 给定一个数n,求这个数的欧拉函数ϕ(n)

#### [超绝大佬解释](https://www.acwing.com/solution/content/8702/):

$$
φ(n)=φ(p_1^{a1})∗…∗φ(p_x^{ax})
\\
=(𝑝_1^{𝑎1}−𝑝_1^{𝑎1−1})∗…∗(𝑝_𝑥^{𝑎𝑥}−𝑝_𝑥^{𝑎𝑥−1})
\\
=𝑝_1^{𝑎1}∗(1−\frac{1}{𝑝1})∗𝑝_2^{𝑎2}∗(1−\frac{1}{𝑝2})∗…∗𝑝_𝑥^{𝑎𝑥}∗(1−\frac{1}{𝑝𝑥})
\\
=p_1^{a1}∗p_2^{a2}∗…∗p_x^{ax}∗(1−\frac{1}{p1})∗(1−\frac{1}{p2})∗…∗(1−\frac{1}{px})
\\
=n∗\prod_{i=1}^{x}(1−\frac{1}{p_i})
$$

#### 涉及容斥定理,yxc的解释也简单易懂,具体请回顾课程,下面给出题解代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;cin>>n;
    while(n --)
    {
        int x;cin>>x;
        long long res = x;
        for(int i = 2; i <= x/i; i ++)
            if(x%i == 0)
            {
                res -= res/i;
                while(x % i == 0)x /= i;
            }
        if(x > 1)res = res*(x-1)/x;
        cout << res << endl;
    }
    
}
```

~~(没错我也很震惊居然这么短)~~
