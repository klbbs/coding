# 基础算法：快速选择

#### 和快速排序算法类似，这个算法是用于求数组中第k大（或者第k小的）数

### 在快速排序中，选择了一个哨兵数（可以不是数组中的数），小于哨兵数的放在左边，大于哨兵数的放在右边，等于哨兵就随便左右都行。不断重复这个步骤最后就完成升序数组的操作。

### 而快速选择目的是找到第k大（或者小）的数，所以每次进行快排的一个步骤后会进行判断，如果M(为哨兵位置，即left=right的时候），如果这个值大于k（以找第k小为例），那就继续快排left到M,否则快排M到right。知道M = k，则可知，nums[M]就是第k小的数.

这是快排：

``````c++
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}

``````

### 有几点要注意下，先附上快选代码:

``````c++

#include <bits/stdc++.h>
using namespace std;

void quick_select(vector<int>&arr,int l,int r,int k){
    if (l >= r) return;
    
    int i = l, j = r;
    int pivot = arr[l];
    while (i < j) {
        while (i < j && arr[j] >= pivot) --j;
        while (i < j && arr[i] <= pivot) ++i;
        if (i < j) swap(arr[i], arr[j]);
    }
    swap(arr[l], arr[j]);
    
    int left_part_size = j - l + 1;
    if (left_part_size >= k) 
        quick_select(arr, l, j, k);  
    else 
        quick_select(arr, j + 1, r, k - left_part_size); 
}

int main() {
    vector<int> arr = {8, 2, 3, 5, 7};
    int k; 
    cin >> k;  // 输入需要找到的第 k 小的元素，注意 k 从 1 开始
    
    cout << quick_select(arr, 0, arr.size() - 1, k) << endl;
    
    return 0;
}
``````

- ##### 在递归处理边界的时候，count代表的是l到j总共元素，如果大于或者等于k，则说明多了，就在左边继续递归（因为在这个写法中左边包含中间，因为递归传入的参数是(arr,l,j,k)），如果k大于count，则说明少了，在继续在右边递归，从j+1到r，同时k改为k-count，因为前面小的数已经放好了。

### 	洛谷1138：题解

``````c++
#include <bits/stdc++.h>
using namespace std;


void sort_(vector<int>&s,int l,int r,int k){
    if(l>=r)return ;
    int i=l,j=k;
    while(i<j){
        while(i<j && s[i]<s[l])i++;
        while(i<j && s[j]>s[l])j--;
        if(i<j)swap(s[i],s[j]);
    }
    swap(s[j],s[l]);
    int st = j - l + 1;
    if(k <= st)return sort_(s,l,j,k);
    else return sort_(s,l,j+1,st - k);
    
}

int main(){
    int n,k;cin>>n>>k;
    vector<int>s(n);
    for(int i=0;i<n;i++)cin>>s[i];
    sort(s.begin(),s.end());
    s.erase(unique(s.begin(),s.end()),s.end());
    if(k>=(int)s.size())cout<<"NO RESULT";
    else cout << s[k-1];
    
}

``````

